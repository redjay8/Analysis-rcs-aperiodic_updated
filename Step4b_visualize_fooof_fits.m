%% Step4b_visualize_fooof_fits.m
%
% This attempts to visualize individual FOOOF fits for selected time windows from LFP data.
% NOTE: only validated on demo data as of now.
% This script loads the processed data, selects specific window(s),
% re-runs the direct Python FOOOF calculation for those windows, and plots
% the power spectrum, the full FOOOF model fit, and the aperiodic component.
%
% **Purpose:** To verify the quality and characteristics of individual FOOOF
% fits generated by the method used in Step4.
%
% **Assume:**
% 1. Steps 1-3 completed successfully.
% 2. Specific combinedDataTable & condition_states files exist in processed_data.
% 3. FieldTrip toolbox is available at the specified path.
% 4. FOOOF Python package is installed and accessible from MATLAB.
% 5. Configuration settings (paths, dataset IDs, channel) match those
%    used in the Step 4 run.

clear;
close all;
clc;

%% --- Configuration ---

% Define project and toolbox paths (MUST MATCH Step 4)
project_base_path = '.\Code preparation';
toolbox_path = '.\Analysis-rcs-data-master';
fieldtrip_path = '.\fieldtrip-master'; % <--- *** UPDATE THIS PATH ***

% Define the folder for processed data output/input
processed_data_folder = fullfile(project_base_path, 'processed_data');

% --- Define which dataset was processed in Step 4 ---
hemi_to_process = 'L';
session_id_to_process = 'Session1691533893108';
device_id_to_process = 'DeviceNPC700545H';

% --- Analysis Parameters (MUST MATCH Step 4) ---
brain_regions = {'+2-0', '+3-1', '+9-8', '+11-10'};
brain_region_names = {'STN_L_02_00', 'STN_L_03_01', 'M1_L_09_08', 'M1_L_11_10'};
chan = 2; % Channel index analyzed in Step 4

% FOOOF / Windowing Parameters (MUST MATCH Step 4)
window_size_sec = 60;
step_size_sec_m1 = 5; % Needed if selecting windows by index from Method 1
med_freq_range = [40 90]; % Freq range OFF/low stim
stim_freq_range = [10 50];% Freq range ON/high stim

% --- Sampling Rate Fallback (MUST MATCH Step 4) ---
known_td_sampling_rate_hz = 250;

% --- *** Select Window(s) to Visualize *** ---

% Method A: Visualize specific window indices from Method 1 results
windows_to_plot_indices = [1, 10, 30]; % Example: Plot the 1st, 10th, and 30th window calculated by Method 1

% Method B: Visualize window(s) centered around specific timestamps (in seconds since recording start)
% Example: Find the window whose center is closest to 100s and 500s into the recording
% windows_to_plot_times_sec = [100, 500];

% Method C: Visualize window(s) ending at specific PKG timestamps (Method 2 style)
% Requires loading PKG times first (see PKG loading section below)
% pkg_indices_to_plot = [2, 5]; % Example: Plot fits for the 2nd and 5th PKG timestamps

% --- Visualization Settings ---
plot_flattened_spectrum = true; % Set to true to add a subplot showing peaks

%% --- 1. Setup paths ---
fprintf('Starting Step 4b: Visualize FOOOF Fits...\n');

% Add toolboxes to path
if ~contains(path, toolbox_path)
    addpath(genpath(toolbox_path));
    fprintf('Analysis-rcs-data toolbox added from: %s\n', toolbox_path);
end
if exist(fieldtrip_path, 'dir') && ~contains(path, fieldtrip_path)
    addpath(fieldtrip_path);
    ft_defaults;
    fprintf('FieldTrip toolbox added from: %s\n', fieldtrip_path);
elseif ~exist(fieldtrip_path, 'dir')
     error('FieldTrip path not found: %s', fieldtrip_path);
else
    fprintf('FieldTrip toolbox already on path.\n');
    ft_defaults;
end

% Check if Python FOOOF module is accessible
try
    fooof_module = py.importlib.import_module('fooof');
    fprintf('FOOOF Python module found and accessible.\n');
catch ME
    error('FOOOF Python module not found or not accessible: %s\nPlease ensure your Python environment is configured correctly.', ME.message);
end

%% --- 2. Load processed neural data and condition states ---

% Construct filenames based on configuration
combined_filename = sprintf('combinedDataTable_%s_%s_%s.mat', ...
                         hemi_to_process, session_id_to_process, device_id_to_process);
states_filename = sprintf('condition_states_%s_%s_%s.mat', ...
                          hemi_to_process, session_id_to_process, device_id_to_process);

combined_file_path = fullfile(processed_data_folder, combined_filename);
states_file_path = fullfile(processed_data_folder, states_filename);

% Load combined data table file
if ~isfile(combined_file_path)
    error('Combined data file not found: %s\nPlease ensure Step 2 ran successfully.', combined_file_path);
end
fprintf('Loading combined neural data from: %s\n', combined_file_path);
loaded_combined = load(combined_file_path);

% Load condition states file
if ~isfile(states_file_path)
    error('Condition states file not found: %s\nPlease ensure Step 3 ran successfully.', states_file_path);
end
fprintf('Loading condition states from: %s\n', states_file_path);
loaded_states = load(states_file_path);

% --- Verify required variables are loaded and assign ---
required_combined_vars = {'combinedDataTable'};
for v = 1:length(required_combined_vars)
    if ~isfield(loaded_combined, required_combined_vars{v})
        error('Variable "%s" not found in loaded file: %s', required_combined_vars{v}, combined_file_path);
    end
    eval([required_combined_vars{v} ' = loaded_combined.(required_combined_vars{v});']);
end

required_states_vars = {'med_state', 'stim_state'};
for v = 1:length(required_states_vars)
    if ~isfield(loaded_states, required_states_vars{v})
        error('Variable "%s" not found in loaded file: %s', required_states_vars{v}, states_file_path);
    end
     eval([required_states_vars{v} ' = loaded_states.(required_states_vars{v});']);
end
fprintf('Data loaded successfully.\n');

%% --- 3. Extract LFP data and parameters ---
fprintf('Setting up LFP analysis parameters...\n');

% Validate channel index
if chan < 1 || chan > length(brain_regions) || chan > length(brain_region_names)
     error('Selected channel index "chan" (%d) is out of bounds for brain_regions/brain_region_names lists (size %d).', chan, length(brain_regions));
end
analysis_region_code = brain_regions{chan};
analysis_region_name = brain_region_names{chan};

% Channel selection
td_channel_idx = chan - 1;
channel_col_name = sprintf('TD_key%d', td_channel_idx);

if ~ismember(channel_col_name, combinedDataTable.Properties.VariableNames)
    error('Channel column "%s" not found in combinedDataTable.', channel_col_name);
end
fprintf('Analyzing channel: %s (%s)\n', analysis_region_name, channel_col_name);

% Extract time series data
time_vector_ms = combinedDataTable.DerivedTime; % POSIX time in MILLISECONDS
signal = combinedDataTable.(channel_col_name);
time_vector_sec = time_vector_ms / 1000; % Convert to seconds

% --- Get sampling rate with fallback (same logic as Step 4) ---
fs = NaN;
if isfield(loaded_combined, 'timeDomainSettings') && isstruct(loaded_combined.timeDomainSettings) && isfield(loaded_combined.timeDomainSettings, 'samplingRate') && ~isempty(loaded_combined.timeDomainSettings.samplingRate) && isscalar(loaded_combined.timeDomainSettings.samplingRate) && isnumeric(loaded_combined.timeDomainSettings.samplingRate) && ~isnan(loaded_combined.timeDomainSettings.samplingRate) && loaded_combined.timeDomainSettings.samplingRate > 0
    fs = loaded_combined.timeDomainSettings.samplingRate;
    fprintf('Using sampling rate loaded from timeDomainSettings: %.2f Hz\n', fs);
    if abs(fs - known_td_sampling_rate_hz) > 1
         warning('Loaded sampling rate (%.2f Hz) differs significantly from expected rate (%.2f Hz).', fs, known_td_sampling_rate_hz);
    end
else
    warning('Could not load valid sampling rate from timeDomainSettings. Using hardcoded value: %d Hz.', known_td_sampling_rate_hz);
    fs = known_td_sampling_rate_hz;
end
if isnan(fs) || fs <= 0
    error('Failed to determine a valid sampling rate (fs). Cannot proceed.');
end
% --- End sampling rate section ---

% Convert window size to samples
window_size_samples = round(window_size_sec * fs);

%% --- 4. Identify and Process Selected Windows ---

% Determine which selection method is active
if exist('windows_to_plot_indices', 'var')
    selection_method = 'index';
    target_values = windows_to_plot_indices;
    fprintf('Visualizing based on Method 1 window indices: %s\n', mat2str(target_values));
elseif exist('windows_to_plot_times_sec', 'var')
    selection_method = 'time';
    target_values = windows_to_plot_times_sec;
    fprintf('Visualizing based on target center times (sec): %s\n', mat2str(target_values));
elseif exist('pkg_indices_to_plot', 'var')
    selection_method = 'pkg_index';
    target_values = pkg_indices_to_plot;
    fprintf('Visualizing based on PKG timestamp indices: %s\n', mat2str(target_values));
    % --- Load PKG data if needed for Method C ---
    % Minimal PKG loading, adapted from Step 4
    pkg_data_folder = fullfile(project_base_path, 'PKG_Data'); % Path from Step 4 config
    pkg_patient_id = 'Pat1'; % Patient ID from Step 4 config
    pkg_times = [];
    if ~exist(pkg_data_folder, 'dir')
        error('PKG data directory not found for Method C: %s', pkg_data_folder);
    else
        pkg_file_pattern = sprintf('%s_*.csv', pkg_patient_id);
        pkg_files = dir(fullfile(pkg_data_folder, pkg_file_pattern));
        if isempty(pkg_files)
            error('No PKG CSV files found for Method C in %s', pkg_data_folder);
        end
        pkg_data_all = table();
        for i = 1:length(pkg_files)
            try
                opts = detectImportOptions(fullfile(pkg_data_folder, pkg_files(i).name), 'TextType', 'string', 'ReadVariableNames', true);
                if ~ismember('Date_Time', opts.VariableNames); continue; end
                opts = setvartype(opts, 'Date_Time', 'string');
                pkg_file_data = readtable(fullfile(pkg_data_folder, pkg_files(i).name), opts);
                if ~ismember('Date_Time', pkg_file_data.Properties.VariableNames); continue; end
                pkg_file_data.datetime = datetime(pkg_file_data.Date_Time);
                pkg_file_data.time = posixtime(pkg_file_data.datetime);
                pkg_data_all = [pkg_data_all; pkg_file_data(:, {'time', 'datetime'})];
            catch ME_read
                 warning('Error reading PKG file %s: %s. Skipping.', pkg_files(i).name, ME_read.message);
            end
        end
        if ~isempty(pkg_data_all)
            pkg_data_all = sortrows(pkg_data_all, 'time');
            pkg_data_all = unique(pkg_data_all,'rows');
            neural_start_time_sec = time_vector_sec(1);
            neural_end_time_sec = time_vector_sec(end);
            pkg_interval_sec = 120; % From Step 4 config
            pkg_in_range_idx = pkg_data_all.time >= neural_start_time_sec & pkg_data_all.time <= (neural_end_time_sec + pkg_interval_sec);
            pkg_times = pkg_data_all.time(pkg_in_range_idx); % PKG times in seconds
            fprintf('Loaded %d relevant PKG timestamps.\n', length(pkg_times));
        end
    end
    if isempty(pkg_times)
        error('Failed to load any relevant PKG timestamps for Method C.');
    end
else
    error('No window selection method chosen. Define windows_to_plot_indices, windows_to_plot_times_sec, or pkg_indices_to_plot.');
end


% Loop through the selected windows/times/indices
for k = 1:length(target_values)
    target_value = target_values(k);
    start_idx = NaN;
    end_idx = NaN;
    window_label = ''; % For plot title

    % --- Determine window indices based on selection method ---
    switch selection_method
        case 'index' % Method 1 index
            window_index = target_value;
            step_size_samples_m1 = round(step_size_sec_m1 * fs);
            start_idx = (window_index-1) * step_size_samples_m1 + 1;
            end_idx = start_idx + window_size_samples - 1;
            if start_idx < 1 || end_idx > length(signal)
                 warning('Window index %d is out of bounds for the signal length. Skipping.', window_index);
                 continue;
            end
            center_time_sec = time_vector_sec(start_idx + round(window_size_samples/2));
            window_label = sprintf('Method 1 Window Index %d (Center ~%.1f s)', window_index, center_time_sec);

        case 'time' % Target center time
            target_time_sec = target_value;
            % Find the Method 1 window whose center is closest
            step_size_samples_m1 = round(step_size_sec_m1 * fs);
            num_windows_m1 = floor((length(signal) - window_size_samples) / step_size_samples_m1) + 1;
            center_times_sec = arrayfun(@(i) time_vector_sec(((i-1)*step_size_samples_m1 + 1) + round(window_size_samples/2)), 1:num_windows_m1);
            [~, closest_idx] = min(abs(center_times_sec - target_time_sec));
            start_idx = (closest_idx-1) * step_size_samples_m1 + 1;
            end_idx = start_idx + window_size_samples - 1;
             if start_idx < 1 || end_idx > length(signal)
                 warning('Window centered near %.1f s is out of bounds. Skipping.', target_time_sec);
                 continue;
            end
            actual_center_time_sec = time_vector_sec(start_idx + round(window_size_samples/2));
            window_label = sprintf('Window centered near %.1f s (Actual center: %.1f s)', target_time_sec, actual_center_time_sec);

        case 'pkg_index' % Method 2 style, ending at PKG time
            pkg_index = target_value;
            if pkg_index < 1 || pkg_index > length(pkg_times)
                 warning('PKG index %d is out of bounds (1 to %d). Skipping.', pkg_index, length(pkg_times));
                 continue;
            end
            end_time_sec = pkg_times(pkg_index);
            start_time_sec = end_time_sec - window_size_sec;
            [~, end_idx] = min(abs(time_vector_sec - end_time_sec));
            [~, start_idx] = min(abs(time_vector_sec - start_time_sec));
            if start_idx < 1 || end_idx > length(signal) || start_idx >= end_idx || time_vector_sec(start_idx) > start_time_sec + 5 || time_vector_sec(end_idx) < end_time_sec - 5
                warning('Window for PKG index %d (ends %.1f s) is out of bounds or invalid. Skipping.', pkg_index, end_time_sec);
                continue;
            end
            window_label = sprintf('Window ending at PKG time %.1f s (Index %d)', end_time_sec, pkg_index);
    end

    % --- Extract data and state for the identified window ---
    if isnan(start_idx) || isnan(end_idx)
        continue; % Skip if indices weren't determined
    end
    window_data = signal(start_idx:end_idx);
    window_time_ms = time_vector_ms(start_idx:end_idx);
    window_time_sec = time_vector_sec(start_idx:end_idx);

    % Determine state and frequency range (same logic as Step 4)
    window_med_state = NaN;
    window_stim_state = NaN;
     if end_idx <= length(med_state) && end_idx <= length(stim_state)
         window_med_state = mode(med_state(start_idx:end_idx));
         window_stim_state = mode(stim_state(start_idx:end_idx));
     else
         warning('State vectors too short for window ending at index %d. State unknown.', end_idx);
     end

    if ~isnan(window_stim_state) && window_stim_state > 0.5 % State = 1 (ON/High)
        freq_range = stim_freq_range;
        state_label = 'Stim ON/High';
    else % State = 0 (OFF/Low) or NaN
        freq_range = med_freq_range;
        state_label = 'Stim OFF/Low/Unknown';
    end

    % Handle NaNs in window data
    nan_frac = sum(isnan(window_data)) / length(window_data);
    if nan_frac > 0.2
        warning('Window %s: High NaN fraction (%.1f%%). Skipping FOOOF.', window_label, nan_frac*100);
        continue;
    end
    window_data(isnan(window_data)) = 0; % Replace NaNs with zero

    % --- Perform FOOOF Fit (Replicating core logic from calculate_aperiodic_direct) ---
    exponent = NaN; offset = NaN; r_squared = NaN; fm = []; pxx = []; f = [];

    try
        % Calculate power spectrum using Welch's method
        % Use a window length suitable for the data, e.g., 2*fs or similar
        nfft = max(256, 2^nextpow2(fs*2)); % Ensure reasonable NFFT
        [pxx, f] = pwelch(window_data, hanning(min(length(window_data), fs*2)), [], nfft, fs); % Use 2s Hann window or full data length if shorter

        % Filter to desired frequency range
        freq_mask = f >= freq_range(1) & f <= freq_range(2);
        f_fit = f(freq_mask);
        pxx_fit = pxx(freq_mask);

        if length(f_fit) < 6
            warning('Window %s: Too few frequency points (%d) for FOOOF in range [%.1f %.1f] Hz. Skipping.', window_label, length(f_fit), freq_range(1), freq_range(2));
            continue;
        end

        % Convert to Python arrays
        py_freqs = py.numpy.array(f_fit);
        py_spectrum = py.numpy.array(pxx_fit);

        % Create FOOOF model (same settings as Step 4's helper)
        fm = py.fooof.FOOOF(pyargs(...
            'peak_width_limits', py.list({1, 8}), ...
            'max_n_peaks', int32(8), ...
            'min_peak_height', 0.05, ...
            'peak_threshold', 2.0, ...
            'aperiodic_mode', 'fixed'));

        % Fit the model
        fm.fit(py_freqs, py_spectrum);

        % Extract parameters for title/display
        aperiodic_params = double(py.array.array('d', fm.aperiodic_params_));
        if length(aperiodic_params) >= 2
            offset = aperiodic_params(1);
            exponent = aperiodic_params(2);
        end
        r_squared = double(fm.r_squared_);

        fprintf('  Fit for %s: Exp=%.3f, Off=%.2f, R2=%.3f\n', window_label, exponent, offset, r_squared);

    catch ME
        warning('Error during FOOOF calculation for window %s: %s', window_label, ME.message);
        fm = []; % Ensure fm is empty if fit failed
    end

    % --- Plot the Fit ---
    if ~isempty(fm) && ~isempty(f) && ~isempty(pxx) % Check if FOOOF ran and PSD exists
        figure('Name', sprintf('FOOOF Fit: %s', window_label), 'Position', [100+k*20 100+k*20 900 700]);

        % Define number of subplots
        n_subplots = 1;
        if plot_flattened_spectrum
            n_subplots = 2;
        end

        % Subplot 1: Log-Log Spectrum and Fit
        subplot(n_subplots, 1, 1);
        hold on;

        % Plot original power spectrum (full range, gray)
        plot(log10(f), log10(pxx), 'Color', [0.7 0.7 0.7], 'LineWidth', 1, 'DisplayName', 'Original Spectrum (Full)');

        % Plot power spectrum used for fitting (black)
        plot(log10(f_fit), log10(pxx_fit), 'k', 'LineWidth', 1.5, 'DisplayName', 'Spectrum (Fit Range)');

        % Plot FOOOF full model fit
        % Need to get the fitted spectrum from the python object
        fooof_fit_log = log10(double(py.array.array('d', fm.fooofed_spectrum_)));
        plot(log10(f_fit), fooof_fit_log, 'r', 'LineWidth', 2, 'DisplayName', 'FOOOF Model Fit');

        % Plot FOOOF aperiodic fit
        % Need to get the aperiodic component from the python object
        % Reconstruct the aperiodic fit using public parameters
        if length(aperiodic_params) >= 2 % Make sure we have offset and exponent
            offset_val = aperiodic_params(1);
            exponent_val = aperiodic_params(2);
            % Calculate log10(Power) = Offset - Exponent * log10(Frequency)
            ap_fit_log = offset_val - exponent_val * log10(f_fit);
        else
            warning('Could not reconstruct aperiodic fit: parameters missing.');
            ap_fit_log = nan(size(f_fit)); % Assign NaN if params aren't available
        end
        plot(log10(f_fit), ap_fit_log, 'b--', 'LineWidth', 2, 'DisplayName', 'Aperiodic Fit');

        hold off;
        grid on;
        xlabel('Log_{10} Frequency (Hz)');
        ylabel('Log_{10} Power (\muV^2/Hz)'); % Adjust unit if known otherwise
        title({sprintf('FOOOF Fit: %s', window_label); ...
               sprintf('Channel: %s (%s), State: %s', analysis_region_name, channel_col_name, state_label); ...
               sprintf('Fit Range: [%.1f-%.1f] Hz, Exp: %.3f, Offset: %.2f, R^2: %.3f', freq_range(1), freq_range(2), exponent, offset, r_squared)});
        legend('show', 'Location', 'southwest');
        xlim(log10([f(2), f(end)])); % Show full frequency range, starting from 2nd point to avoid log10(0) if f(1)=0

        % Subplot 2: Flattened Spectrum and Peaks (Optional)
        if plot_flattened_spectrum
            subplot(n_subplots, 1, 2);
            hold on;

            % Calculate flattened spectrum (spectrum - aperiodic fit) in log power
            flat_spec_log = log10(pxx_fit) - ap_fit_log;

            % Plot flattened spectrum
            plot(f_fit, flat_spec_log, 'k', 'LineWidth', 1.5, 'DisplayName', 'Flattened Spectrum (log)');

            % Plot peak fit component (if peaks were found)
            try % Check if peaks exist
                peak_params = cell(fm.peak_params_); % Convert Python list of lists/arrays to MATLAB cell
                if ~isempty(peak_params)
                    peak_fit_log = log10(double(py.array.array('d', fm.peak_fit_)));
                    plot(f_fit, peak_fit_log, 'r', 'LineWidth', 2, 'DisplayName', 'Peak Fit (log)');
                else
                     text(mean(f_fit), mean(flat_spec_log), 'No peaks found', 'HorizontalAlignment', 'center');
                end
            catch % Handle cases where peak extraction might fail
                 text(mean(f_fit), mean(flat_spec_log), 'Could not plot peaks', 'HorizontalAlignment', 'center');
            end

            hold off;
            grid on;
            xlabel('Frequency (Hz)');
            ylabel('Log_{10} Power (Residual)');
            title('Flattened Spectrum & Peak Component');
            legend('show', 'Location', 'best');
            xlim(freq_range); % Limit x-axis to the fit range for clarity
        end

    end % End check if fm is valid

end % End loop through windows

fprintf('\nStep 4b visualization complete.\n');